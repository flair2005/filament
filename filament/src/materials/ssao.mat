material {
    name : ssao,
    parameters : [
        {
           type : sampler2d,
           name : depth
        },
        {
            type : float,
            name : radius
        },
        {
            type : float,
            name : bias
        },
        {
            type : float,
            name : power
        }
    ],
    variables : [
         vertex
    ],
    vertexDomain : device,
    depthWrite : false,
    depthCulling : false,
    shadingModel : unlit,
    variantFilter : [ skinning ],
    culling: none
}

vertex {
    void materialVertex(inout MaterialVertexInputs material) {
        // far-plane in view space
        vec4 position = getPosition(); // clip-space
        material.vertex.xy = (position.xy * 0.5 + 0.5);
        material.vertex.zw = position.xy;
    }
}

fragment {
    const uint kSphereSampleCount = 16u;
    const vec3 kSphereSamples[16] = vec3[](
        vec3(-1.60954e-06,3.93118e-07,1.51895e-06), vec3(-0.0950889,0.00458908,-0.0312535),
        vec3(0.0151799,-0.0255864,0.00376453), vec3(0.0734262,0.0218022,0.0027781),
        vec3(0.0945874,0.0432184,0.0891475), vec3(-0.00950861,0.0513686,0.019673),
        vec3(0.139973,-0.101685,0.10857), vec3(-0.103804,0.219853,-0.0430164),
        vec3(0.00484053,-0.0339878,0.0941868), vec3(0.0280114,0.0584662,-0.25711),
        vec3(-0.0510306,0.074993,0.259843), vec3(0.118822,-0.186537,-0.134192),
        vec3(0.0639494,-0.0948936,-0.072683), vec3(0.108176,0.327108,-0.254058),
        vec3(-0.0471796,0.21918,0.263895), vec3(-0.407709,0.240834,-0.200352)
    );

    const uint kNoiseSampleCount = 16u;
    const vec3 kNoiseSamples[kNoiseSampleCount] = vec3[](
        vec3(-0.0782473,-0.749924,-0.65688), vec3(-0.572319,-0.102379,-0.813615), vec3(0.0486527,-0.380791,0.92338), vec3(0.281202,-0.656664,-0.699799),
        vec3(0.711911,-0.235841,-0.661485), vec3(-0.445893,0.611063,0.65405), vec3(-0.703598,0.674837,0.222587), vec3(0.768236,0.507457,0.390257),
        vec3(-0.670286,-0.470387,0.57398), vec3(0.199235,0.849336,-0.488808), vec3(-0.768068,-0.583633,-0.26352), vec3(-0.89733,0.328853,0.294372),
        vec3(-0.57093,-0.531056,-0.626114), vec3(0.699014,0.0632826,-0.712303), vec3(0.207495,0.976129,-0.0641723), vec3(-0.0609008,-0.869738,-0.489742)
    );

    const uint kSpiralSampleCount = 7;
    const vec3 kSipralSamples[kSpiralSampleCount] = vec3[](
        vec3(0.885456,0.464723,0.0769231), vec3(0.120537,0.992709,0.230769), vec3(-0.748511,0.663123,0.384615), vec3(-0.970942,-0.239316,0.538462),
        vec3(-0.354605,-0.935016,0.692308), vec3(0.568065,-0.822984,0.846154), vec3(1,1.74846e-07,1)
    );

    const uint kTrigNoiseSampleCount = 16;
    const vec3 kTrigNoiseSamples[kTrigNoiseSampleCount] = vec3[](
        vec3(0.0759449,0.997112,0.0317202), vec3(-0.53898,-0.842318,0.0879207), vec3(0.672069,0.740488,0.0176937), vec3(-0.323441,-0.946248,0.0930107),
        vec3(0.330969,0.943642,0.026175), vec3(0.341023,-0.940055,0.107385), vec3(-0.197094,0.980384,0.0375434), vec3(0.106268,-0.994338,0.102259),
        vec3(0.955394,0.295335,0.00636207), vec3(0.306817,0.951768,0.0267157), vec3(-0.882675,0.469983,0.056284), vec3(0.671194,-0.741282,0.115615),
        vec3(-0.958342,0.285624,0.0605199), vec3(0.954542,-0.298078,0.12691), vec3(-0.586923,-0.809643,0.0866893), vec3(0.679755,-0.73344,0.115861)
);

    float random(const vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);
    }

    vec3 getNoise(const vec2 uv) {
        uint ix = uint(gl_FragCoord.x) & 3u;
        uint iy = uint(gl_FragCoord.y) & 3u;
        vec3 noise = kNoiseSamples[ix + iy * 4];
        //vec3 noise = normalize(vec3(random(uv), random(uv*2.0), random(uv*4.0)));
        return noise;
    }

    vec3 getTrigNoise(const vec2 uv) {
        //const float dalpha = 1.0f / (float(kSpiralSampleCount) - 0.5f);
        //const float dturns = (1.0 * 6.28318);
        //const float dphi = dalpha * dturns + 6.28318;
        //float phi = random(uv) * 0.5 + 0.5;
        //return vec3(cos(phi * dphi), sin(phi * dphi), phi * dalpha);
        uint ix = uint(gl_FragCoord.x) & 3u;
        uint iy = uint(gl_FragCoord.y) & 3u;
        vec3 noise = kTrigNoiseSamples[ix + iy * 4];
        return noise;
    }

    vec3 computeViewSpaceNormalNotNormalized(const vec3 position) {
        vec3 dpdx = dFdx(position);
        vec3 dpdy = dFdy(position);
        return cross(dpdx, dpdy);
    }

    float linearizeDepth(float depth) {
        mat4 projection = getClipFromViewMatrix();
        float z = depth * 2.0 - 1.0; // depth in clip space
        return -projection[3].z / (z + projection[2].z);
    }

    float sampleDepthLinear(const vec2 uv) {
        return linearizeDepth(texture(materialParams_depth, uv, 0.0).r);
    }

    vec3 computeViewSpacePositionFromDepth(in vec2 p, float linearDepth) {
        mat4 projection = getClipFromViewMatrix();
        p.x = p.x * (-1.0 / projection[0].x);   // could be in a ubo
        p.y = p.y * (-1.0 / projection[1].y);   // could be in a ubo
        return vec3(p * linearDepth, linearDepth);
    }

    float computeAmbientOcclusion(const vec3 origin, const vec3 normal, const vec3 noise, const vec3 sphereSample) {
        mat4 projection = getClipFromViewMatrix();
        float radius = materialParams.radius;
        float bias = materialParams.bias;

        vec3 r = sphereSample * radius;
        r = reflect(r, noise);
        r = sign(dot(r, normal)) * r;
        vec3 samplePos = origin + r;

        vec4 samplePosScreen = projection * vec4(samplePos, 1.0);
        samplePosScreen.xy = samplePosScreen.xy * (0.5 / samplePosScreen.w) + 0.5;

        float occlusionDepth = sampleDepthLinear(samplePosScreen.xy);

        // smoothstep() optimized for range 0 to 1
        float t = saturate(radius / abs(origin.z - occlusionDepth));
        float rangeCheck = t * t * (3.0 - 2.0 * t);

        float d = samplePos.z - occlusionDepth; // distance from depth to sample
        return (d >= -bias ? 0.0 : rangeCheck);
    }

    vec3 tapLocation(uint i, const vec3 noise) {
        //const float dalpha = 1.0f / (float(kSpiralSampleCount) - 0.5f);
        //const float dturns = (1.0 * 6.28318);
        //float phi = noise.z / dalpha;
        //float alpha = (float(i) + 0.5) * dalpha + phi * (dalpha * dturns + 6.28318);
        //float radius = alpha + phi * dalpha;
        //vec3(cos(alpha), sin(alpha), radius * radius);
        mat2 M = mat2(noise.xy, vec2(-noise.y, noise.x));
        float radius = kSipralSamples[i].z + noise.z;
        return vec3(M * kSipralSamples[i].xy, radius * radius);
    }

    float computeAmbientOcclusion2(uint i, float ssDiskRadius, const ivec2 ssOrigin, const vec3 origin, const vec3 normal, const vec3 noise) {
        float radius = materialParams.radius;
        float invRadiusSquared = 1.0 / (radius * radius);
        float bias = materialParams.bias;

        vec3 tl = tapLocation(i, noise);
        float ssRadius = max(0.75, tl.z * ssDiskRadius);
        ivec2 ssSamplePos = ssOrigin + ivec2(ssRadius * tl.xy);

        ivec2 textureSamplePos = clamp(ssSamplePos, ivec2(0), textureSize(materialParams_depth, 0) - ivec2(1));
        float occlusionDepth = linearizeDepth(texelFetch(materialParams_depth, textureSamplePos, 0).r);

        vec2 uvSamplePos = (vec2(ssSamplePos) + vec2(0.5)) * frameUniforms.resolution.zw;
        vec3 p = computeViewSpacePositionFromDepth(uvSamplePos * 2.0 - 1.0, occlusionDepth);

        // now we have the sample, compute AO
        vec3 v = p - origin;        // sample vector
        float vv = dot(v, v);       // squared distance
        float vn = dot(v, normal);  // distance * cos(v, normal)
        const float uu = 0.015;
        float falloff = saturate(1.0 - vv * invRadiusSquared);
        float occlusion = falloff * max(0.0, vn - bias) / (vv + uu);
        return occlusion;
    }

    void material(inout MaterialInputs material) {
        prepareMaterial(material);

        float radius = materialParams.radius;

        // Pixels-per-meter at z=-1
        // -height / (2.0 * tan(verticalFieldOfView * 0.5))
        const float projScale = 500;

        vec2 uv = variable_vertex.xy; // interpolated to pixel center

        float depth = sampleDepthLinear(uv);
        vec3 origin = computeViewSpacePositionFromDepth(variable_vertex.zw, depth);
        ivec2 ssOrigin = ivec2(uv * frameUniforms.resolution.xy);
        vec3 normal = computeViewSpaceNormalNotNormalized(origin);

        // attempt to reject "bad" normals that were reconstructed at an edge that cause
        // false occlusion (black spots)
        // Normal's length should be small before they're normalized, unless they're bad ones.
        if (dot(normal, normal) >= (sq(origin.z * origin.z * 0.000061))) {
            // For now we assume no occlusion, which is wrong in some case, but overall seem to
            // look better.  Maybe those could be handled in the blur pass instead?
            material.baseColor.r = 1.0;
            return;
        }

        // Choose the screen-space sample radius
        // proportional to the projected area of the sphere
        float ssDiskRadius = -projScale * radius / origin.z;
        if (ssDiskRadius <= 1.0) {
            // There is no way to compute AO at this radius
            material.baseColor.r = 1.0;
            return;
        }

        normal = normalize(normal);
        float occlusion = 0.0;
        float ao;

        if (uv.x < 0.5) {
            vec3 noise = getNoise(uv);
            for (uint i = 0u; i < kSphereSampleCount; i++) {
                occlusion += computeAmbientOcclusion(origin, normal, noise, kSphereSamples[i]);
            }
            ao = 1.0 - occlusion / float(kSphereSampleCount);
        } else {
            vec3 noise = getTrigNoise(uv);
            for (uint i = 0u; i < kSpiralSampleCount; i++) {
                occlusion += computeAmbientOcclusion2(i, ssDiskRadius, ssOrigin, origin, normal, noise);
            }
            ao = 1.0 - occlusion / float(kSpiralSampleCount);
        }

        // simulate user-controled ao^n with n[1, 2]
        ao = mix(ao, ao * ao, materialParams.power);
        material.baseColor.r = ao;
    }
}
